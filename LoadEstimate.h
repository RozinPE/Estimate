//---------------------------------------------------------------------------

#ifndef LoadEstimateH
#define LoadEstimateH
//--------------------------------------------------------------------------
//функция возвращает матрицу перехода из J2000 в Гринвичскую СК
// на вход подается время t (отсчитываемое от 01.01.2018 в секундах ДМВ)
// вычисленная матрица запишется в m (размерность массива 9 элементов)
typedef void (*TToGreenwich)(double t, double *m); 
//--------------------------------------------------------------------------
// для работы с функцией TToGreenwich необходимо осуществить инициализацию данных
// с помощью этой функции создается внутри библиотеки обхект класса
// который потом надо удалить, после заверщения работы с библиотекой, вызвав CloseLib
typedef void (*TInit)();
//--------------------------------------------------------------------------
// удаляет динамически созданные в библиотеке экземпляры классов
typedef void (*TCloseLib)();
//--------------------------------------------------------------------------
// вычисление факториала числа k
typedef double (*Tfact)( int k );
//--------------------------------------------------------------------------
// возвращает возвещение x в целочисленную степень n
typedef double (*Tpw)( double x, int n );
//--------------------------------------------------------------------------
// заполняет n элементов массива a числами r
typedef void (*Tscla)( double *a, double r, int n );
//--------------------------------------------------------------------------
// умножение вектора a размерности n на число r (т.е поэлементно)
// результат записывается в b
typedef void (*Tsmpy)( double *a, double r, double *b, int n );
//--------------------------------------------------------------------------
// копирует n элементов массива a в массив b
typedef void (*Tmcpy)( double *a, double *b, int n );
//--------------------------------------------------------------------------
// суммирует поэлементно массивы a и b размерности n и записывает результат в c
typedef void (*Tmadd)( double *a, double *b, double *c, int n );
//--------------------------------------------------------------------------
// вычитает поэлементно массивы a и b размерности n и записывает результат в c
typedef void (*Tmsub)( double *a, double *b, double *c, int n );
//--------------------------------------------------------------------------
// Умножает матрицу a, представленную в виде одномерного массива, на матрицу b, 
// также представленную в виде массива.
//Размерность матриц [m,n], где  m – количество сток, n – количество столбцов. 
//В качестве параметра принимает ma – число строк матрицы a, 
//na – число столбцов матрицы a, nb – число столбцов матрицы b.
// результат записывается в c
typedef void (*Tmprd)( double *a, double *b, double *c, int ma, int na, int nb );
//--------------------------------------------------------------------------
// транспонирует матрицу a размерности [m,n], где  m – количество сток, n – количество столбцов. 
// результат записывает в b
typedef void (*Tmtra) ( double *a, double *b, int ma, int na );
//--------------------------------------------------------------------------
// скалярное произведение векторов a на b каждый из которых длинной n
typedef double (*Tscal) ( double *a, double *b, int n );
//--------------------------------------------------------------------------
// нормирует вектор r размерности, результат записывает в r0, а в rr возвращает длинну начального вектора
typedef void (*Tnorm) ( double *r, int n, double *r0, double & rr );
//--------------------------------------------------------------------------
// нормирует вектор r, результат записывает в r0 (допустимо делать: unit(r,r)
// в этом случае исходный вектор перезапишется нормированым)
typedef int (*Tunit) ( double *r, double *r0 );
//--------------------------------------------------------------------------
// вектроное произведение векторов a на b, если j=1, то в первые 3 элемента 
// вектора c запишутся значения результата, остальные элементы c останутся как были
// если j = 0, то помимо предыдущего действия во вторые три элемента вектора c
// нормированный вектор от результата перемножение, а длинна вектора результата запишется 
// в последний элемент вектора с 
typedef void (*Tmvec) ( int j, double a[3], double b[3], double c[7]);
//--------------------------------------------------------------------------
// 
typedef void (*Tort) ( double *r, double d, double & fi, double & psi);
//--------------------------------------------------------------------------
// возвращает матрицу поворота вокруг оси i на угол angle (в радианах)
// i = 0 - поворот вокруг X, i=1 - поворот вокруг y, i = 2 - поворот вокруг Z
typedef void (*Tmrot) ( double angle, double *mat, int i );
//--------------------------------------------------------------------------
// возвращает юлианскую дату вдя указанных входных параметров в UTC
typedef double (*Tdjul)(int day, int mon, int year, int hour, int min, int sec);
//--------------------------------------------------------------------------
// ию юлианской даты tj восстанавливает значения дня, месяца, года и т.д в UTC
typedef void (*Tdatej) (double tj, int &id, int &im, int &iy, int &ih, int &imin, int &is);
//--------------------------------------------------------------------------
// по известной широте и долготе формирует матницу перехода в топоцентрическую СК
typedef void (*Ttopo) ( double lat, double lon, double *mat );
//--------------------------------------------------------------------------
// обращение квадратной положительно определенной матрицы. Результирующая матрица формируется на месте входной
typedef bool (*Tsinv) ( double *mat, int n );
//--------------------------------------------------------------------------
// функция умножения A*B*Aтранспонированную, результат запишется в C
// на вход так же идет количество столбцов в матрице B и C
typedef void (*TABAT) ( double *A, double *B, double *C, int nB, int nC );
//--------------------------------------------------------------------------
// умножает матрицу А на транспонированную матрицу А с количеством строк nRows и столбцов nCols
// результат записывается в B
typedef void (*TATA) ( double *A, double *B, int nRows, int nCols );
//--------------------------------------------------------------------------
// принимает на вход число секунд t отсчитанное от 01.01.2018 00:00:00.000 
// и формирует строку вышеуказанного формата в массив *str
typedef void (*Tt2TimeStrMs) ( double t, char *str );
//--------------------------------------------------------------------------
// принимает на вход число секунд t отсчитанное от 01.01.2018 00:00:00 
// и формирует строку вышеуказанного формата в массив *str
// фактически тоже, что предыдущая функция, но без миллисекунд
typedef void (*Tt2TimeStr)( double t, char *str );
//--------------------------------------------------------------------------
// из строки формата "01.01.2018 00:00:00.000" возвращает число типа double
// секунд, прошедших с 01.01.2018 00:00:00.000 (число может быть и отрицательным)
typedef double (*TTimeStrMs2t) ( char *s );
//--------------------------------------------------------------------------
// линейная интерполяция функции y(x) заданной таблично в виде двух массивов
// x и y размерностью n каждый. Возвращает значение y в момент xx
// если xx за пределами значений аргументов массива x, возвращается крайнее значение из массива y
typedef double (*TLinIntF)( double *x, double *y, int n, double xx );
//--------------------------------------------------------------------------
// угол между векторами a и b в радианах
typedef double (*Tangle_vect)(double * a, double *b);
//--------------------------------------------------------------------------
// умножение кватерниона b на a, результат в c
typedef void (*Tquatmul)( double *b, double *a, double *c );
//--------------------------------------------------------------------------
// формирование кватерниона q из матрицы направляющих косинусов m
// случае успеха возвращается true, иначе flase
typedef bool (*Tm2q)( double *m, double *q );
//--------------------------------------------------------------------------
// формирование матриы m из кватерниона q
typedef void (*Tq2m)( double *q, double *m );
//--------------------------------------------------------------------------
// нормирование кватерниона q
typedef void (*Tquatnorm)( double *q );
//--------------------------------------------------------------------------
// поиск корней уравнения f(x), на интервале x0, xk, с шагом dx, и заданной точностью 
// нахождения корней eps. Корни записываются в X и возвращается количество найденных корней
typedef int (*TRoots)(double f(double),double x0,double xk,double dx,double eps,double *X);
//--------------------------------------------------------------------------
// возвращает случайное число распределенное по нормальному закону распределение
// при заданном СКО (sigma) и матожидании mean
typedef double (*Tgauss) ( double sigma, double mean );
//--------------------------------------------------------------------------
// генератор случайных чисел распределенных по равномерному закону распределения 
// на интервале от xmin до xmax
typedef double (*TUniform) ( double xmin, double xmax );
//--------------------------------------------------------------------------
// обращение матрицы mat размерности n на n
typedef bool (*Tminv)( double *mat, int n, double &d );
//--------------------------------------------------------------------------
// делает один шаг интегрирования методом рунге-кутты 4 порядка для функции 
// f(double t, double *x, double *dx)
// начальные условия интегирования в массиве y, результат записывается в yk,
// расмерность массива y - n, шаг интегрирования h
typedef void (*TRK4)( void f(double, double*, double*),
				  double t, double *y, double *yk, int n, double h);
//--------------------------------------------------------------------------
// вычисляет определенный интеграл функции func(x) на интервале от a до b
// методом симпсона
typedef double (*Tqsimp)( double (*func)(double), double a, double b );
//---------------------------------------------------------------------------
typedef void (*TGetMagField)(double t, double *x, double *B);
// вычисление вектора магнитной индукции Земли на момент t (количество секунд от 01.01.2018 00:00:00 ДМВ)
// для КА с фазовым вектором x в J2000. Результат запишется в B (вектор из 3 элементов, нТл) в J2000
//---------------------------------------------------------------------------
class TMathLib
{
 private:
  HINSTANCE Lib;
 public:
  TToGreenwich ToGreenwich;
  TGetMagField GetMagField;
  TInit Init;
  TCloseLib CloseLib;
  Tfact  fact;
  Tpw    pw;
  Tscla  scla;
  Tsmpy  smpy;
  Tmcpy  mcpy;
  Tmadd  madd;
  Tmsub  msub;
  Tmprd  mprd;
  Tmtra  mtra;
  Tscal  scal;
  Tnorm  norm;
  Tunit  unit;
  Tmvec  mvec;
  Tort   ort;
  Tmrot  mrot;
  Tdjul  djul;
  Tdatej datej;
  Ttopo  topo;
  Tsinv  sinv;
  TABAT  ABAT;
  TATA   ATA;
  Tt2TimeStrMs t2TimeStrMs;
  Tt2TimeStr t2TimeStr;
  TTimeStrMs2t TimeStrMs2t;
  TLinIntF LinIntF;
  Tangle_vect angle_vect;
  Tquatmul quatmul;
  Tm2q     m2q;
  Tq2m     q2m;
  Tquatnorm quatnorm;
  TRoots Roots;
  Tgauss gauss;
  TUniform Uniform;
  Tminv minv;
  TRK4  RK4;
  Tqsimp qsimp;
  bool LoadDLL();
};
//---------------------------------------------------------------------------


#endif


